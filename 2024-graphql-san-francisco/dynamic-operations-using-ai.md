
# Executive Summary

This document, presented by Michael Watson at GraphQLConf 2024, introduces a technique for **dynamic GraphQL operations** using AI to generate safe and trusted GraphQL queries from text prompts. The core idea involves leveraging **Large Language Models (LLMs)** and **GraphQL schema embeddings** to dynamically create operations that are validated and optimized for security and correctness.

The system discussed in this presentation integrates **RAG (Retrieval-Augmented Generation)** to combine the flexibility of LLMs with the structure and rigor of GraphQL APIs. By embedding the schema in a vector store, the system enables accurate generation of operations, ensuring that the generated operations conform to the API's schema and expected behavior.

**Key Benefits:**
1. **Automated Query Generation**: LLMs can easily understand GraphQL queries and generate them based on user input, removing the need for manual query writing.
2. **Schema-Aware AI**: By embedding the GraphQL schema, the AI ensures that generated queries are valid and safe to execute.
3. **Flexibility and Efficiency**: The system provides a user-friendly way for developers and non-technical users to interact with APIs using natural language, while maintaining the safety of traditional API interaction methods.

**Challenges:**
1. **Performance**: Embedding large schemas and running vector searches can introduce latency.
2. **Complexity**: Setting up and maintaining the system requires expertise in both GraphQL and AI technologies.

The technique promises to streamline how developers and even non-technical users can interact with GraphQL APIs by dynamically generating queries that are both safe and efficient.


# Notes

1. **Dynamic Operations**: 
   - The system generates GraphQL operations from text prompts using an LLM.
   - Operations are verified against the embedded schema, ensuring type safety and correctness.

2. **GraphQL Vector Embedding**:
   - A vector store is used to embed the GraphQL schema, which allows for quick lookup and validation of operations generated by the LLM.
   - The embedding process happens when the schema changes, updating the stored vectorized data.

3. **AI-Powered Query Generation**:
   - The system uses a combination of LLMs and vector searches to produce GraphQL operations.
   - It allows developers to use natural language prompts like "How do I get ... from the API?" to retrieve data safely from the GraphQL API.

4. **Performance Considerations**:
   - Embedding large schemas can introduce latency during operation generation and execution.
   - The system relies on caching and optimized vector searches to mitigate some of the performance issues.

5. **Use of RAG (Retrieval-Augmented Generation)**:
   - The system combines RAG to ensure that the generated operations are contextually aware of the API schema and follow best practices for GraphQL queries.


# Recommendations

## When to Use Dynamic GraphQL Operations with AI-Powered Query Generation

1. **Non-Technical User Interfaces**:
   - This technique is ideal for environments where non-technical users need to interact with complex APIs. The AI-powered system simplifies API usage by converting natural language into valid GraphQL queries.

2. **Large and Complex APIs**:
   - For projects with large and evolving schemas, dynamically generating GraphQL queries from text prompts can significantly reduce the complexity of writing and maintaining queries manually.

3. **Enhancing Developer Productivity**:
   - Developers can benefit from this approach when they need to quickly generate safe operations without deep knowledge of the schema or the API, allowing for faster prototyping and iteration.

4. **Custom Applications**:
   - This technique is suited for custom applications where the schema is dynamic or frequently changing, as the system adapts to schema changes by re-embedding the schema into a vector store.

5. **Secure and Type-Safe Queries**:
   - In applications where query safety and type correctness are critical, this approach ensures that all dynamically generated operations are validated against the schema, reducing the risk of errors or security vulnerabilities.
